# Live ID Check: Add Image Upload (Following Listing Pattern)

**Date:** 2025-11-29  
**Status:** üîç **ASSESSMENT - NOT IMPLEMENTED**

---

## üìã Requirement

**Current:** LIVE_ID_CHECK request accepts **1 video only**

**New:** LIVE_ID_CHECK request accepts **1 video + 1 image** (both required)

**Storage:** Both files stored under same REQUEST record, both tracked in DynamoDB

---

## ‚úÖ **Design Decision: Follow Listing Submit-Intent Pattern**

Your existing **listing submission** already handles multiple files elegantly. We should follow the **exact same pattern**:

### **Listing Pattern (Existing):**

```typescript
// Request body
{
  images: [
    {
      imageId: "img_123",
      contentType: "image/jpeg",
      displayOrder: 1,
      isPrimary: true,
    },
    {
      imageId: "img_456",
      contentType: "image/jpeg",
      displayOrder: 2,
      isPrimary: false,
    },
    // ...
  ];
}

// Response
{
  imageUploadUrls: [
    { imageId: "img_123", uploadUrl: "https://...", expiresAt: "..." },
    { imageId: "img_456", uploadUrl: "https://...", expiresAt: "..." },
    // ...
  ];
}
```

### **Apply Same Pattern to LIVE_ID_CHECK:**

```typescript
// Request body
{
  files: [
    { fileId: "video_123", contentType: "video/mp4", fileType: "VIDEO" },
    { fileId: "image_456", contentType: "image/jpeg", fileType: "IMAGE" },
  ];
}

// Response
{
  uploadUrls: [
    { fileId: "video_123", uploadUrl: "https://...", expiresAt: "..." },
    { fileId: "image_456", uploadUrl: "https://...", expiresAt: "..." },
  ];
}
```

---

## üîÑ Proposed Implementation

### Step 1: Update Types

**File:** `backend/services/types/request.types.ts`

```typescript
// Add to SubmitRequestIntentRequest
export interface SubmitRequestIntentRequest {
  files: Array<{
    fileId: string; // UUID generated by frontend
    contentType: string; // video/mp4, video/mov, video/webm, image/jpeg, image/png, image/webp
    fileType: "VIDEO" | "IMAGE";
  }>;
}

// Add to SubmitRequestIntentResponse
export interface SubmitRequestIntentResponse {
  requestId: string;
  submissionToken: string;
  uploadUrls: Array<{
    fileId: string;
    fileType: "VIDEO" | "IMAGE";
    uploadUrl: string;
    expiresAt: string;
  }>;
  maxVideoSizeMB: number;
  maxImageSizeMB: number;
}

// Add to Request interface
export interface Request {
  // ... existing fields ...

  // LIVE_ID_CHECK file tracking
  files?: Array<{
    fileId: string;
    fileType: "VIDEO" | "IMAGE";
    s3Key: string; // Final S3 key after processing
    fileSize: number;
    contentType: string;
    uploadedAt: string;
    status: "PENDING_UPLOAD" | "UPLOADED" | "QUARANTINED";
  }>;

  // ... rest of fields ...
}
```

---

### Step 2: Update Submit Intent

**File:** `backend/services/api/requests/submit-intent.ts`

```typescript
const SUBMISSION_TOKEN_EXPIRY_MINUTES = 30;
const MAX_VIDEO_SIZE_MB = 100;
const MAX_IMAGE_SIZE_MB = 10;

const ALLOWED_VIDEO_TYPES = ["video/mp4", "video/mov", "video/webm"];
const ALLOWED_IMAGE_TYPES = ["image/jpeg", "image/png", "image/webp"];

export async function handler(
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> {
  // ... auth and validation ...

  const requestBody: SubmitRequestIntentRequest = JSON.parse(event.body);

  // Validate files array
  if (!requestBody.files || requestBody.files.length !== 2) {
    return response.badRequest("Exactly 2 files required (1 video + 1 image)");
  }

  // Find video and image
  const videoFile = requestBody.files.find((f) => f.fileType === "VIDEO");
  const imageFile = requestBody.files.find((f) => f.fileType === "IMAGE");

  if (!videoFile || !imageFile) {
    return response.badRequest("Must include 1 VIDEO and 1 IMAGE file");
  }

  // Validate content types
  if (!ALLOWED_VIDEO_TYPES.includes(videoFile.contentType)) {
    return response.badRequest(
      `Invalid video content type. Allowed: ${ALLOWED_VIDEO_TYPES.join(", ")}`
    );
  }

  if (!ALLOWED_IMAGE_TYPES.includes(imageFile.contentType)) {
    return response.badRequest(
      `Invalid image content type. Allowed: ${ALLOWED_IMAGE_TYPES.join(", ")}`
    );
  }

  // ... fetch request, validate status ...

  // Generate submission token
  const submissionToken = `req_sub_${randomUUID()}`;
  const tokenExpiresAt = new Date(
    Date.now() + SUBMISSION_TOKEN_EXPIRY_MINUTES * 60 * 1000
  );

  // Create file records and generate upload URLs (following listing pattern)
  const uploadUrls: SubmitRequestIntentResponse["uploadUrls"] = [];

  for (const file of requestBody.files) {
    const extension = getFileExtension(file.contentType);
    const s3Key = `veri_live-id-check-${file.fileType.toLowerCase()}_${requestId}_${
      file.fileId
    }.${extension}`;
    const finalS3Key = `${hostId}/requests/${requestId}/live-id-check-${file.fileType.toLowerCase()}.${extension}`;

    // Create placeholder file record (following listing image pattern)
    await docClient.send(
      new PutCommand({
        TableName: TABLE_NAME,
        Item: {
          pk: `REQUEST#${requestId}`,
          sk: `FILE#${file.fileId}`,

          requestId,
          hostId,
          fileId: file.fileId,
          fileType: file.fileType,

          s3Key, // Root location with veri_ prefix
          finalS3Key, // Final destination after scan

          contentType: file.contentType,
          fileSize: 0, // Will be updated after upload

          status: "PENDING_UPLOAD",

          uploadedAt: new Date().toISOString(),
          isDeleted: false,
        },
      })
    );

    // Generate pre-signed URL with metadata
    const uploadUrl = await generateUploadUrl(
      s3Key,
      file.contentType,
      SUBMISSION_TOKEN_EXPIRY_MINUTES * 60,
      {
        hostId,
        requestId,
        fileId: file.fileId,
        fileType: file.fileType,
      }
    );

    uploadUrls.push({
      fileId: file.fileId,
      fileType: file.fileType,
      uploadUrl,
      expiresAt: tokenExpiresAt.toISOString(),
    });
  }

  // Update request with submission token
  await docClient.send(
    new UpdateCommand({
      TableName: TABLE_NAME,
      Key: {
        pk: `HOST#${hostId}`,
        sk: `REQUEST#${requestId}`,
      },
      UpdateExpression:
        "SET submissionToken = :token, submissionTokenExpiresAt = :expiresAt, updatedAt = :now",
      ExpressionAttributeValues: {
        ":token": submissionToken,
        ":expiresAt": tokenExpiresAt.toISOString(),
        ":now": new Date().toISOString(),
      },
    })
  );

  // Build response
  const intentResponse: SubmitRequestIntentResponse = {
    requestId,
    submissionToken,
    uploadUrls,
    maxVideoSizeMB: MAX_VIDEO_SIZE_MB,
    maxImageSizeMB: MAX_IMAGE_SIZE_MB,
  };

  return response.success(intentResponse);
}

function getFileExtension(contentType: string): string {
  const map: Record<string, string> = {
    "video/mp4": "mp4",
    "video/mov": "mov",
    "video/webm": "webm",
    "image/jpeg": "jpg",
    "image/png": "png",
    "image/webp": "webp",
  };
  return map[contentType.toLowerCase()] || "mp4";
}
```

---

### Step 3: Update Confirm Submission

**File:** `backend/services/api/requests/confirm-submission.ts`

```typescript
export async function handler(
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> {
  // ... auth, validation, fetch request ...

  const { submissionToken } = requestBody;

  // ... validate submission token ...

  // Fetch all file records (following listing confirm pattern)
  const filesResult = await docClient.send(
    new QueryCommand({
      TableName: TABLE_NAME,
      KeyConditionExpression: "pk = :pk AND begins_with(sk, :sk)",
      ExpressionAttributeValues: {
        ":pk": `REQUEST#${requestId}`,
        ":sk": "FILE#",
      },
    })
  );

  const fileRecords = filesResult.Items || [];

  if (fileRecords.length !== 2) {
    return response.badRequest("Expected 2 files (1 video + 1 image)");
  }

  // Note: Like listing submission, we DON'T check S3 existence
  // Because GuardDuty + verification processor are very fast (3-5 seconds)
  // By the time confirm is called, files may already be processed and moved
  // DynamoDB record existence is sufficient proof of upload

  // Verify we have both video and image
  const hasVideo = fileRecords.some((f) => f.fileType === "VIDEO");
  const hasImage = fileRecords.some((f) => f.fileType === "IMAGE");

  if (!hasVideo || !hasImage) {
    return response.badRequest("Must upload both video and image files");
  }

  // Update request status to RECEIVED
  const now = new Date().toISOString();

  await docClient.send(
    new UpdateCommand({
      TableName: TABLE_NAME,
      Key: {
        pk: `HOST#${hostId}`,
        sk: `REQUEST#${requestId}`,
      },
      UpdateExpression:
        "SET #status = :status, uploadedAt = :uploadedAt, updatedAt = :updatedAt, gsi2sk = :gsi2sk " +
        "REMOVE submissionToken, submissionTokenExpiresAt",
      ExpressionAttributeNames: {
        "#status": "status",
      },
      ExpressionAttributeValues: {
        ":status": "RECEIVED",
        ":uploadedAt": now,
        ":updatedAt": now,
        ":gsi2sk": `STATUS#RECEIVED#${now}`,
      },
    })
  );

  return response.success({
    requestId,
    status: "RECEIVED",
    message: "Live ID check files received successfully",
  });
}
```

---

### Step 4: Update Verification Processor

**File:** `backend/services/verification-processor/index.js`

```javascript
async function determineFileType(s3Key, metadata) {
  const hostId = metadata.hostid;
  const requestId = metadata.requestid;
  const fileId = metadata.fileid;
  const fileType = metadata.filetype; // 'VIDEO' or 'IMAGE'

  // ... existing handlers for profile-doc, listing-doc, property-video ...

  // LIVE_ID_CHECK files: veri_live-id-check-video_{requestId}_{fileId}.ext
  //                  or: veri_live-id-check-image_{requestId}_{fileId}.ext
  if (
    s3Key.startsWith("veri_live-id-check-video_") ||
    s3Key.startsWith("veri_live-id-check-image_")
  ) {
    const extension = s3Key.split(".").pop().toLowerCase();
    const fileTypeLower = fileType.toLowerCase(); // 'video' or 'image'

    return {
      pk: `REQUEST#${requestId}`,
      sk: `FILE#${fileId}`,
      finalS3Key: `${hostId}/requests/${requestId}/live-id-check-${fileTypeLower}.${extension}`,
      quarantineKey: `${hostId}/quarantine/${s3Key}`,
      isVideo: fileType === "VIDEO",
      fileType,
    };
  }

  console.error(`Unknown verification file type: ${s3Key}`);
  return {};
}

async function handleCleanFile(bucket, key) {
  // ... existing logic ...

  const { pk, sk, finalS3Key, isVideo, fileType } = await determineFileType(
    key,
    metadata
  );

  // ... copy to final destination, delete from root ...

  // Update file record status (following listing image pattern)
  await docClient.send(
    new UpdateCommand({
      TableName: TABLE_NAME,
      Key: { pk, sk },
      UpdateExpression:
        "SET #status = :status, s3Key = :s3Key, fileSize = :fileSize, updatedAt = :now",
      ConditionExpression: "attribute_exists(pk)",
      ExpressionAttributeNames: {
        "#status": "status",
      },
      ExpressionAttributeValues: {
        ":status": "UPLOADED",
        ":s3Key": finalS3Key,
        ":fileSize": fileSize,
        ":now": now,
      },
    })
  );

  console.log(`‚úÖ Successfully moved ${key} to ${finalS3Key}`);
}
```

**Note:** No need to update the main REQUEST record - the file records track individual file status.

---

## üìä Database Schema

### New: FILE Records (Per-File Tracking)

```typescript
{
  pk: "REQUEST#{requestId}",
  sk: "FILE#{fileId}",

  requestId: "req_123...",
  hostId: "host_456...",
  fileId: "uuid...",
  fileType: "VIDEO" | "IMAGE",

  s3Key: "host_456.../requests/req_123.../live-id-check-video.mp4",  // Final location
  finalS3Key: "...",  // Same as s3Key after processing

  contentType: "video/mp4",
  fileSize: 50000000,

  status: "PENDING_UPLOAD" | "UPLOADED" | "QUARANTINED",

  uploadedAt: "2025-11-29T10:00:00Z",
  isDeleted: false,
}
```

### Unchanged: REQUEST Record

```typescript
{
  pk: "HOST#{hostId}",
  sk: "REQUEST#{requestId}",

  requestId: "req_123...",
  requestType: "LIVE_ID_CHECK",
  status: "RECEIVED",  // Set by confirm-submission

  submissionToken: "req_sub_456...",  // Temporary during upload
  submissionTokenExpiresAt: "...",

  uploadedAt: "2025-11-29T10:05:00Z",  // Set when both files uploaded
  // ... rest of fields ...
}
```

---

## üéØ Key Benefits of This Pattern

### ‚úÖ **Consistency**

- Follows existing listing submission pattern exactly
- Same mental model for frontend developers
- Same testing patterns
- Same error handling

### ‚úÖ **Flexibility**

- Easy to add more files in the future (e.g., "selfie + ID front + ID back")
- Each file tracked independently
- Can handle files arriving in any order
- Can handle partial failures (one file infected, other clean)

### ‚úÖ **Simplicity**

- No need to hardcode "video" and "image" fields in REQUEST record
- Verification processor logic is simpler (one file type handler)
- Confirm-submission just queries FILE records (no manual S3 checks)

### ‚úÖ **Scalability**

- Adding a 3rd file type? Just add to the array
- No schema migration needed
- No new DynamoDB fields needed

---

## üìù Files to Modify

| File                                                  | Changes                                                                                         | Complexity |
| ----------------------------------------------------- | ----------------------------------------------------------------------------------------------- | ---------- |
| `backend/services/types/request.types.ts`             | Add `files` array to request/response types                                                     | üü¢ Low     |
| `backend/services/api/requests/submit-intent.ts`      | Loop through `files` array, create FILE records, generate upload URLs                           | üü¢ Low     |
| `backend/services/api/requests/confirm-submission.ts` | Query FILE records, validate both exist                                                         | üü¢ Low     |
| `backend/services/verification-processor/index.js`    | Handle `veri_live-id-check-video_` and `veri_live-id-check-image_` prefixes, update FILE record | üü¢ Low     |
| `REQUESTS_API_SPEC.md`                                | Update API documentation                                                                        | üü¢ Low     |

**Total Effort:** ~2-3 hours development + 1 hour testing = **~3-4 hours total**

**Reduced from 5-6 hours!** Because we're following an existing pattern.

---

## üß™ Testing Strategy

### Unit Tests

- [ ] Submit intent with 2 files (1 video + 1 image)
- [ ] Submit intent with 1 file only (should fail)
- [ ] Submit intent with 3 files (should fail)
- [ ] Submit intent with 2 videos (should fail)
- [ ] Submit intent with 2 images (should fail)
- [ ] Confirm submission after both files uploaded (should succeed)
- [ ] Confirm submission after only 1 file uploaded (should fail)

### Integration Tests

- [ ] Full flow: Submit intent ‚Üí Upload both files ‚Üí Confirm ‚Üí Scan ‚Üí Process ‚Üí Admin review
- [ ] Video arrives first, then image
- [ ] Image arrives first, then video
- [ ] One file infected (should quarantine that file, other file still processed)

---

## üöÄ Deployment Plan

### Phase 1: Backend (No Breaking Changes)

1. Deploy updated types
2. Deploy submit-intent with file array pattern
3. Deploy confirm-submission with FILE record queries
4. Deploy verification-processor with new S3 key patterns

### Phase 2: Frontend

1. Update to send `files` array instead of `contentType`
2. Update to handle array of `uploadUrls` in response
3. Update progress UI to show both files

### Phase 3: Admin Dashboard

1. Query FILE records to display both video + image
2. Add UI to show both files side-by-side

---

## ‚úÖ Recommendation

**Use the listing pattern!** It's:

- ‚úÖ Already proven in production
- ‚úÖ More flexible (easy to add more files later)
- ‚úÖ Simpler code (no hardcoded video/image fields)
- ‚úÖ Easier to test (same patterns as listing submission)
- ‚úÖ **Faster to implement** (copy-paste existing patterns)

---

**Last Updated:** 2025-11-29




