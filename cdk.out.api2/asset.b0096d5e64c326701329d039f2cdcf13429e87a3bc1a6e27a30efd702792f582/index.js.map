{
  "version": 3,
  "sources": ["../../backend/services/api/hosts/get-subscription.ts", "../../backend/services/api/lib/auth.ts", "../../backend/services/api/lib/response.ts"],
  "sourcesContent": ["/**\n * Get Host Subscription Lambda Handler\n * Retrieves host subscription details and entitlements\n */\n\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, GetCommand } from '@aws-sdk/lib-dynamodb';\n\nimport { getAuthContext, assertCanAccessHost } from '../lib/auth';\nimport * as response from '../lib/response';\n\nconst client = new DynamoDBClient({ region: process.env.AWS_REGION });\nconst docClient = DynamoDBDocumentClient.from(client);\n\nconst TABLE_NAME = process.env.TABLE_NAME!;\n\ninterface HostSubscription {\n  pk: string;\n  sk: string;\n  hostId: string;\n  planName: string;\n  maxListings: number;\n  status: string;\n  startedAt: string;\n  expiresAt: string | null;\n  cancelledAt: string | null;\n  createdAt: string;\n  updatedAt: string;\n}\n\ninterface SubscriptionPlan {\n  pk: string;\n  sk: string;\n  planName: string;\n  displayName: string;\n  maxListings: number;\n  monthlyPrice: number;\n  description: string;\n  isActive: boolean;\n  sortOrder: number;\n}\n\n/**\n * Main Lambda handler\n */\nexport async function handler(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  console.log('Get subscription request:', {\n    path: event.path,\n    method: event.httpMethod,\n    pathParameters: event.pathParameters,\n  });\n\n  try {\n    // 1. Extract authentication context\n    const auth = getAuthContext(event);\n    const hostId = event.pathParameters?.hostId;\n\n    if (!hostId) {\n      return response.badRequest('hostId is required in path');\n    }\n\n    // 2. Verify authorization\n    assertCanAccessHost(auth, hostId);\n\n    // 3. Fetch host subscription\n    const subscription = await getHostSubscription(hostId);\n\n    if (!subscription) {\n      return response.notFound(`Subscription not found for host: ${hostId}`);\n    }\n\n    // 4. Fetch subscription plan details\n    const plan = await getSubscriptionPlan(subscription.planName);\n\n    // 5. Build simplified response\n    const subscriptionResponse = {\n      hostId: subscription.hostId,\n      planName: subscription.planName,\n      displayName: plan?.displayName || subscription.planName,\n      status: subscription.status,\n      maxListings: subscription.maxListings,\n      monthlyPrice: plan?.monthlyPrice || 0.00,\n      description: plan?.description || '',\n      startedAt: subscription.startedAt,\n      expiresAt: subscription.expiresAt,\n      cancelledAt: subscription.cancelledAt,\n      isActive: subscription.status === 'ACTIVE',\n    };\n\n    return response.success(subscriptionResponse);\n\n  } catch (error: any) {\n    console.error('Get subscription error:', error);\n    return response.handleError(error);\n  }\n}\n\n/**\n * Get host subscription from DynamoDB\n */\nasync function getHostSubscription(hostId: string): Promise<HostSubscription | null> {\n  const result = await docClient.send(\n    new GetCommand({\n      TableName: TABLE_NAME,\n      Key: {\n        pk: `HOST#${hostId}`,\n        sk: 'SUBSCRIPTION',\n      },\n    })\n  );\n\n  return result.Item as HostSubscription | null;\n}\n\n/**\n * Get subscription plan configuration from DynamoDB\n */\nasync function getSubscriptionPlan(planName: string): Promise<SubscriptionPlan | null> {\n  const result = await docClient.send(\n    new GetCommand({\n      TableName: TABLE_NAME,\n      Key: {\n        pk: `SUBSCRIPTION_PLAN#${planName}`,\n        sk: 'CONFIG',\n      },\n    })\n  );\n\n  return result.Item as SubscriptionPlan | null;\n}\n", "/**\n * Authentication and Authorization Utilities\n * Extracts and validates JWT claims from API Gateway events\n */\n\nimport { APIGatewayProxyEvent } from 'aws-lambda';\n\nexport interface AuthContext {\n  userId: string;              // Cognito sub\n  email: string;\n  hostId?: string;             // Optional - only present for HOST role\n  role: 'HOST' | 'ADMIN';\n  permissions: string[];\n  hostStatus?: string;         // Optional - only present for HOST role\n}\n\n/**\n * Extract authentication context from API Gateway event\n * API Gateway Cognito Authorizer populates requestContext.authorizer.claims\n * \n * @throws Error if claims are missing or invalid\n */\nexport function getAuthContext(event: APIGatewayProxyEvent): AuthContext {\n  const claims = event.requestContext.authorizer?.claims;\n  \n  if (!claims) {\n    throw new Error('UNAUTHORIZED: No authentication claims found');\n  }\n  \n  // Validate required claims\n  if (!claims.sub) {\n    throw new Error('UNAUTHORIZED: Missing user ID in claims');\n  }\n  \n  if (!claims.email) {\n    throw new Error('UNAUTHORIZED: Missing email in claims');\n  }\n  \n  if (!claims.role || !['HOST', 'ADMIN'].includes(claims.role)) {\n    throw new Error('UNAUTHORIZED: Invalid or missing role in claims');\n  }\n\n  // hostId is only required for HOST role\n  if (claims.role === 'HOST' && !claims.hostId) {\n    throw new Error('UNAUTHORIZED: Missing hostId in claims for HOST user');\n  }\n  \n  // Parse permissions (comma-separated string in JWT)\n  let permissions: string[] = [];\n  try {\n    if (claims.permissions && typeof claims.permissions === 'string') {\n      // Split comma-separated string and filter out empty strings\n      permissions = claims.permissions.split(',').filter((p: string) => p.trim().length > 0);\n    }\n  } catch (error) {\n    console.error('Failed to parse permissions from JWT:', error);\n    permissions = [];\n  }\n  \n  return {\n    userId: claims.sub,\n    email: claims.email,\n    hostId: claims.hostId,\n    role: claims.role as 'HOST' | 'ADMIN',\n    permissions,\n    hostStatus: claims.hostStatus || 'UNKNOWN',\n  };\n}\n\n/**\n * Check if user has a specific permission\n */\nexport function hasPermission(auth: AuthContext, permission: string): boolean {\n  return auth.permissions.includes(permission);\n}\n\n/**\n * Check if user can access a specific host's resources\n * Admins can access any host, hosts can only access their own\n */\nexport function canAccessHost(auth: AuthContext, targetHostId: string): boolean {\n  if (auth.role === 'ADMIN') {\n    return true;\n  }\n  \n  return auth.hostId === targetHostId;\n}\n\n/**\n * Check if user can perform an operation on a host\n */\nexport function canPerformOperation(\n  auth: AuthContext,\n  targetHostId: string,\n  operation: 'read' | 'write' | 'delete'\n): boolean {\n  // Admins have full access\n  if (auth.role === 'ADMIN') {\n    return true;\n  }\n  \n  // Hosts can only access their own resources\n  if (auth.hostId !== targetHostId) {\n    return false;\n  }\n  \n  // Check specific permissions\n  const permissionMap: Record<string, string> = {\n    read: 'listings:read',\n    write: 'listings:write',\n    delete: 'listings:delete',\n  };\n  \n  return hasPermission(auth, permissionMap[operation]);\n}\n\n/**\n * Assert user can access host (throws if not)\n */\nexport function assertCanAccessHost(auth: AuthContext, targetHostId: string): void {\n  if (!canAccessHost(auth, targetHostId)) {\n    throw new Error(\n      `FORBIDDEN: User ${auth.userId} (host: ${auth.hostId}) cannot access host ${targetHostId}`\n    );\n  }\n}\n\n/**\n * Assert user has permission (throws if not)\n */\nexport function assertHasPermission(auth: AuthContext, permission: string): void {\n  if (!hasPermission(auth, permission)) {\n    throw new Error(\n      `FORBIDDEN: User ${auth.userId} does not have permission: ${permission}`\n    );\n  }\n}\n\n/**\n * Assert user is an admin (throws if not)\n */\nexport function assertIsAdmin(auth: AuthContext): void {\n  if (auth.role !== 'ADMIN') {\n    throw new Error(\n      `FORBIDDEN: User ${auth.userId} is not an admin`\n    );\n  }\n}\n\n", "/**\n * Standard API Response Builders\n * Consistent response format across all API endpoints\n */\n\nimport { APIGatewayProxyResult } from 'aws-lambda';\n\n/**\n * Standard CORS headers\n */\nconst CORS_HEADERS = {\n  'Content-Type': 'application/json',\n  'Access-Control-Allow-Origin': '*', // TODO: Configure based on environment\n  'Access-Control-Allow-Credentials': 'true',\n  'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n  'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',\n};\n\n/**\n * Success response (200)\n */\nexport function success<T>(data: T, statusCode: number = 200): APIGatewayProxyResult {\n  return {\n    statusCode,\n    headers: CORS_HEADERS,\n    body: JSON.stringify(data),\n  };\n}\n\n/**\n * Created response (201)\n */\nexport function created<T>(data: T): APIGatewayProxyResult {\n  return success(data, 201);\n}\n\n/**\n * No content response (204)\n */\nexport function noContent(): APIGatewayProxyResult {\n  return {\n    statusCode: 204,\n    headers: CORS_HEADERS,\n    body: '',\n  };\n}\n\n/**\n * Bad request error (400)\n */\nexport function badRequest(message: string, details?: unknown): APIGatewayProxyResult {\n  const body: Record<string, unknown> = {\n    error: 'BAD_REQUEST',\n    message,\n  };\n  if (details) {\n    body.details = details;\n  }\n  return {\n    statusCode: 400,\n    headers: CORS_HEADERS,\n    body: JSON.stringify(body),\n  };\n}\n\n/**\n * Unauthorized error (401)\n */\nexport function unauthorized(message: string = 'Unauthorized'): APIGatewayProxyResult {\n  return {\n    statusCode: 401,\n    headers: CORS_HEADERS,\n    body: JSON.stringify({\n      error: 'UNAUTHORIZED',\n      message,\n    }),\n  };\n}\n\n/**\n * Forbidden error (403)\n */\nexport function forbidden(message: string = 'Forbidden'): APIGatewayProxyResult {\n  return {\n    statusCode: 403,\n    headers: CORS_HEADERS,\n    body: JSON.stringify({\n      error: 'FORBIDDEN',\n      message,\n    }),\n  };\n}\n\n/**\n * Not found error (404)\n */\nexport function notFound(message: string = 'Resource not found'): APIGatewayProxyResult {\n  return {\n    statusCode: 404,\n    headers: CORS_HEADERS,\n    body: JSON.stringify({\n      error: 'NOT_FOUND',\n      message,\n    }),\n  };\n}\n\n/**\n * Conflict error (409)\n */\nexport function conflict(message: string, details?: unknown): APIGatewayProxyResult {\n  const body: Record<string, unknown> = {\n    error: 'CONFLICT',\n    message,\n  };\n  if (details) {\n    body.details = details;\n  }\n  return {\n    statusCode: 409,\n    headers: CORS_HEADERS,\n    body: JSON.stringify(body),\n  };\n}\n\n/**\n * Unprocessable entity (422) - validation errors\n */\nexport function unprocessableEntity(message: string, validationErrors?: unknown): APIGatewayProxyResult {\n  const body: Record<string, unknown> = {\n    error: 'VALIDATION_ERROR',\n    message,\n  };\n  if (validationErrors) {\n    body.validationErrors = validationErrors;\n  }\n  return {\n    statusCode: 422,\n    headers: CORS_HEADERS,\n    body: JSON.stringify(body),\n  };\n}\n\n/**\n * Too many requests (429) - rate limit exceeded\n */\nexport function tooManyRequests(message: string = 'Rate limit exceeded'): APIGatewayProxyResult {\n  return {\n    statusCode: 429,\n    headers: CORS_HEADERS,\n    body: JSON.stringify({\n      error: 'RATE_LIMIT_EXCEEDED',\n      message,\n    }),\n  };\n}\n\n/**\n * Internal server error (500)\n */\nexport function internalError(message: string = 'Internal server error', error?: Error): APIGatewayProxyResult {\n  // Log error for debugging (will appear in CloudWatch)\n  if (error) {\n    console.error('Internal error:', {\n      message: error.message,\n      stack: error.stack,\n      name: error.name,\n    });\n  }\n  \n  return {\n    statusCode: 500,\n    headers: CORS_HEADERS,\n    body: JSON.stringify({\n      error: 'INTERNAL_SERVER_ERROR',\n      message,\n    }),\n  };\n}\n\n/**\n * Handle common errors and return appropriate response\n */\nexport function handleError(error: unknown): APIGatewayProxyResult {\n  console.error('Error occurred:', error);\n  \n  if (error instanceof Error) {\n    const message = error.message;\n    \n    // Check for specific error patterns\n    if (message.includes('UNAUTHORIZED')) {\n      return unauthorized(message.replace('UNAUTHORIZED: ', ''));\n    }\n    \n    if (message.includes('FORBIDDEN')) {\n      return forbidden(message.replace('FORBIDDEN: ', ''));\n    }\n    \n    if (message.includes('NOT_FOUND')) {\n      return notFound(message.replace('NOT_FOUND: ', ''));\n    }\n    \n    if (message.includes('VALIDATION_ERROR')) {\n      return badRequest(message.replace('VALIDATION_ERROR: ', ''));\n    }\n    \n    if (message.includes('CONFLICT')) {\n      return conflict(message.replace('CONFLICT: ', ''));\n    }\n    \n    // Default to internal error\n    return internalError('An unexpected error occurred', error);\n  }\n  \n  return internalError('An unknown error occurred');\n}\n\n"],
  "mappings": "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",
  "names": ["get_subscription_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_lib_dynamodb", "getAuthContext", "event", "claims", "permissions", "p", "error", "canAccessHost", "auth", "targetHostId", "assertCanAccessHost", "auth", "targetHostId", "canAccessHost", "CORS_HEADERS", "success", "data", "statusCode", "badRequest", "message", "details", "body", "CORS_HEADERS", "unauthorized", "forbidden", "notFound", "conflict", "internalError", "message", "error", "CORS_HEADERS", "handleError", "unauthorized", "forbidden", "notFound", "badRequest", "conflict", "client", "docClient", "TABLE_NAME", "handler", "event", "auth", "getAuthContext", "hostId", "badRequest", "assertCanAccessHost", "subscription", "getHostSubscription", "notFound", "plan", "getSubscriptionPlan", "subscriptionResponse", "success", "error", "handleError", "planName"]
}
